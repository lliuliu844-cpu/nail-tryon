<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>美甲试戴 · 手部照片预览 + 调试</title>
  <style>
    :root { --bg:#0f1115; --panel:#171a21; --muted:#9aa0a6; --text:#e6e6e6; --warn:#ff7272; --ok:#6ee7a8; }
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
         background:var(--bg);color:var(--text);display:flex;height:100vh;overflow:hidden}
    #left{flex:1;display:flex;align-items:center;justify-content:center;background:#000;position:relative}
    #right{width:420px;padding:14px;background:var(--panel);overflow:auto}
    h2{margin:6px 0 10px 0}
    video{display:none}
    canvas{max-width:100%;max-height:100%;background:#000;border-radius:10px}
    .btn{display:block;width:100%;margin:8px 0;padding:10px;border:0;border-radius:10px;
         background:#2a2f3a;color:#fff;cursor:pointer}
    .btn:hover{background:#343b49}
    input[type=file], input[type=range], select{width:100%;margin:8px 0}
    label{font-size:12px;color:var(--muted);display:block;margin-top:6px}
    #thumb{width:100%;border-radius:8px;border:1px solid #222;background:#111}
    #status{font-size:12px;color:#bbb;margin:6px 0;white-space:pre-wrap}
    #banner{position:absolute;top:10px;left:10px;right:10px;background:#222a;color:#fff;
            padding:8px 10px;border-radius:8px;font-size:12px;line-height:1.4;display:none}
    #banner.warn{background:#4a1f1f}
    #banner.ok{background:#1f3f2b}
    .row{display:flex;gap:8px}
    .row .btn{flex:1}
    .note{color:#9aa0a6;font-size:12px}
    #editWrap{border:1px solid #333;border-radius:8px;padding:8px;margin-top:8px;background:#0b0d12}
    #edit{width:100%;background:#111;border-radius:8px;touch-action:none}
    .segchip{padding:4px 8px;border-radius:999px;border:1px solid #333;background:#1a1f2b;cursor:pointer}
    .segchip.active{border-color:#5b8cff;background:#223055}
    #controls{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  </style>
</head>
<body>
  <div id="left">
    <div id="banner" class="warn"></div>
    <video id="cam" playsinline muted></video>
    <canvas id="canvas" width="1280" height="720"></canvas>
  </div>
  <div id="right">
    <h2>美甲试戴 · 手部照片预览 + 调试</h2>
    <div id="controls">
      <button id="startCam" class="btn">开启相机</button>
      <button id="flipCam" class="btn">切换镜头</button>
      <button id="freeze" class="btn">冻结当前帧</button>
      <button id="usePhoto" class="btn">用手部照片预览</button>
    </div>
    <input type="file" id="handFile" accept="image/*" style="display:none"/>
    <input type="file" id="styleFile" accept="image/*" />
    <img id="thumb" alt="贴片预览" />
    <div id="status">先选一张“款式图片”（JPG/PNG/WEBP/HEIC）。相机不开也能用“手部照片预览”。</div>

    <div class="row">
      <span class="segchip active" id="tool_fg">前景画笔</span>
      <span class="segchip" id="tool_bg">背景画笔</span>
      <span class="segchip" id="tool_rect">矩形框</span>
      <label style="margin-left:auto">画笔</label>
      <input type="range" id="brush" min="4" max="40" step="1" value="16" style="width:120px"/>
    </div>

    <div id="editWrap">
      <canvas id="edit" width="320" height="220"></canvas>
      <div class="row">
        <button id="autoRect" class="btn">自动框选（80%）</button>
        <button id="doGrabCut" class="btn">执行 GrabCut</button>
        <button id="refine" class="btn">细化</button>
      </div>
    </div>

    <label>覆盖透明度</label>
    <input type="range" id="alpha" min="0.3" max="1" step="0.05" value="0.95" />

    <label>大小缩放（整体）</label>
    <input type="range" id="scale" min="0.8" max="2.2" step="0.05" value="1.35" />

    <label>贴合位置（靠近指尖 ←→ 靠近关节）</label>
    <input type="range" id="along" min="0.45" max="0.8" step="0.01" value="0.58" />

    <label>长度系数（纵向）</label>
    <input type="range" id="lenK" min="1.0" max="2.8" step="0.05" value="1.9" />

    <label>宽度系数（横向）</label>
    <input type="range" id="widK" min="0.8" max="2.2" step="0.05" value="1.35" />

    <div class="row">
      <label><input type="checkbox" id="showDots"/> 显示手部关键点</label>
      <button id="snap" class="btn">拍照保存</button>
    </div>

    <p class="note">若相机不开或没检测到手：点“用手部照片预览”，上传你的手照片，系统会在这张照片上套贴片。</p>
  </div>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
  <!-- HEIC 转换 -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>
  <!-- OpenCV.js（主源） -->
  <script src="https://docs.opencv.org/4.9.0/opencv.js"></script>

  <script>
    const banner = document.getElementById('banner');
    const showWarn = (m)=>{ banner.textContent=m; banner.className='warn'; banner.style.display='block'; };
    const showOK = (m)=>{ banner.textContent=m; banner.className='ok'; banner.style.display='block'; };

    const video = document.getElementById('cam');
    const cvs = document.getElementById('canvas'); const ctx = cvs.getContext('2d');
    const startBtn = document.getElementById('startCam');
    const flipBtn = document.getElementById('flipCam');
    const freezeBtn = document.getElementById('freeze');
    const usePhotoBtn = document.getElementById('usePhoto');
    const handFile = document.getElementById('handFile');
    const fileInput = document.getElementById('styleFile');
    const snapBtn = document.getElementById('snap');
    const showDots = document.getElementById('showDots');
    const thumb = document.getElementById('thumb');
    const statusEl = document.getElementById('status');

    const alphaEl=document.getElementById('alpha');
    const scaleEl=document.getElementById('scale');
    const alongEl=document.getElementById('along');
    const lenKEl=document.getElementById('lenK');
    const widKEl=document.getElementById('widK');

    const edit = document.getElementById('edit'); const ectx = edit.getContext('2d');
    const marks = document.createElement('canvas'); const mctx = marks.getContext('2d');
    let editImg=null, rect=null, tool='fg', brushSize=16, isDown=false, startX=0,startY=0;
    const chipFg=document.getElementById('tool_fg');
    const chipBg=document.getElementById('tool_bg');
    const chipRect=document.getElementById('tool_rect');
    const brush=document.getElementById('brush');
    chipFg.onclick=()=>setTool('fg'); chipBg.onclick=()=>setTool('bg'); chipRect.onclick=()=>setTool('rect'); brush.oninput=()=>brushSize=parseInt(brush.value,10);
    function setTool(t){ tool=t; [chipFg,chipBg,chipRect].forEach(x=>x.classList.remove('active')); ({fg:chipFg,bg:chipBg,rect:chipRect}[t]).classList.add('active'); }

    let stream=null, handsInst=null, facing='environment';
    let patchImg=null, frozenImage=null, usePhoto=false;

    let params = { alpha:parseFloat(alphaEl.value), scale:parseFloat(scaleEl.value), along:parseFloat(alongEl.value), lenK:parseFloat(lenKEl.value), widK:parseFloat(widKEl.value) };
    alphaEl.oninput=()=>params.alpha=parseFloat(alphaEl.value);
    scaleEl.oninput=()=>params.scale=parseFloat(scaleEl.value);
    alongEl.oninput=()=>params.along=parseFloat(alongEl.value);
    lenKEl.oninput=()=>params.lenK=parseFloat(lenKEl.value);
    widKEl.oninput=()=>params.widK=parseFloat(widKEl.value);

    function makeSample(){
      const c=document.createElement('canvas'); c.width=c.height=320;
      const g=c.getContext('2d');
      g.clearRect(0,0,320,320);
      g.save(); g.translate(160,180); g.rotate(-0.02);
      g.beginPath(); g.moveTo(-70,60);
      g.quadraticCurveTo(-100,0,-50,-120);
      g.quadraticCurveTo(0,-150,50,-120);
      g.quadraticCurveTo(100,0,70,60);
      g.quadraticCurveTo(0,90,-70,60); g.closePath(); g.clip();
      const grd=g.createLinearGradient(0,-150,0,90);
      grd.addColorStop(0,'rgba(255,200,210,0.96)');
      grd.addColorStop(0.6,'rgba(230,120,160,0.92)');
      grd.addColorStop(1,'rgba(180,80,120,0.9)');
      g.fillStyle=grd; g.fillRect(-160,-160,320,320);
      g.globalAlpha=0.35; g.fillStyle='#fff'; g.beginPath(); g.ellipse(-18,-40,22,55,0,0,Math.PI*2); g.fill();
      g.restore();
      const img=new Image(); img.src=c.toDataURL('image/png'); return img;
    }
    patchImg = makeSample(); thumb.src = patchImg.src;

    // ====== 手部照片预览（相机不开也能用） ======
    usePhotoBtn.addEventListener('click', ()=> handFile.click());
    handFile.addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return;
      const img = await fileToImage(f, 1280);
      frozenImage = img; usePhoto=true;
      cvs.width = img.width; cvs.height = img.height;
      await runHandsOnImage(img);
      drawLoopOnce();
      showOK('已加载手部照片');
    });

    // ====== 相机 ======
    async function openCamera(){
      usePhoto=false; frozenImage=null;
      if(!navigator.mediaDevices?.getUserMedia){ showWarn('浏览器不支持相机 API'); return; }
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:facing}, width:{ideal:1280}, height:{ideal:720} }, audio:false });
      }catch(err){
        try{ stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false }); }
        catch(err2){ showWarn('相机失败：请检查 HTTPS & 权限'); return; }
      }
      cam.srcObject=stream;
      cam.onloadedmetadata=()=>{ cvs.width = cam.videoWidth||1280; cvs.height = cam.videoHeight||720; };
      try{ await cam.play(); }catch(e){}
      ensureHands();
      requestAnimationFrame(loop);
      showOK('相机已开启');
    }
    const cam=document.getElementById('cam');
    startBtn.addEventListener('click', openCamera);
    flipBtn.addEventListener('click', ()=>{ facing=(facing==='environment')?'user':'environment'; if(stream) openCamera(); });
    freezeBtn.addEventListener('click', ()=>{ if(cam.readyState>=2){ const img=new Image(); const c=document.createElement('canvas'); c.width=cvs.width; c.height=cvs.height; const g=c.getContext('2d'); g.drawImage(cam,0,0,c.width,c.height); img.src=c.toDataURL('image/png'); img.onload=()=>{ frozenImage=img; usePhoto=true; runHandsOnImage(img).then(drawLoopOnce); showOK('已冻结当前帧'); }; } });

    // ====== MediaPipe Hands ======
    function ensureHands(){
      if(handsInst) return;
      handsInst=new Hands({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}` });
      handsInst.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.5 });
      handsInst.onResults(onResults);
    }
    let lastLandmarks = null;
    function onResults(res){
      lastLandmarks = res.multiHandLandmarks || null;
      drawLoopOnce(res.image);
    }
    async function runHandsOnImage(img){
      ensureHands();
      await handsInst.send({image: img});
    }
    function drawLoopOnce(imgSrc){
      const w=cvs.width, h=cvs.height; ctx.clearRect(0,0,w,h);
      if(usePhoto && frozenImage){ ctx.drawImage(frozenImage,0,0,w,h); }
      else if(imgSrc){ ctx.drawImage(imgSrc,0,0,w,h); }
      if(lastLandmarks && lastLandmarks.length){
        if(showDots.checked){
          ctx.save(); ctx.fillStyle='rgba(0,255,120,0.9)';
          lastLandmarks.forEach(lm=>lm.forEach(p=>ctx.fillRect(p.x*w-2,p.y*h-2,4,4))); ctx.restore();
        }
        for(const lm of lastLandmarks){ drawNails(lm); }
      }
    }
    async function loop(){ if(!usePhoto && handsInst && cam.readyState>=2){ await handsInst.send({image:cam}); } requestAnimationFrame(loop); }

    function drawNails(lm){
      const fingers=[{pip:2,dip:3,tip:4},{pip:6,dip:7,tip:8},{pip:10,dip:11,tip:12},{pip:14,dip:15,tip:16},{pip:18,dip:19,tip:20}];
      for(const f of fingers){
        const P=lm[f.pip], D=lm[f.dip], T=lm[f.tip]; if(!P||!D||!T) continue;
        const Pp={x:P.x*cvs.width,y:P.y*cvs.height};
        const Dp={x:D.x*cvs.width,y:D.y*cvs.height};
        const Tp={x:T.x*cvs.width,y:T.y*cvs.height};
        const vdx=Tp.x-Dp.x, vdy=Tp.y-Dp.y;
        const len=Math.hypot(vdx,vdy);
        const widthBase=Math.hypot(Dp.x-Pp.x,Dp.y-Pp.y);
        const angle=Math.atan2(vdy,vdx);
        const cx=Dp.x+(Tp.x-Dp.x)*params.along;
        const cy=Dp.y+(Tp.y-Dp.y)*params.along;
        const w=Math.max(10,widthBase*params.widK*params.scale);
        const h=Math.max(14,len*params.lenK*params.scale);

        ctx.save();
        ctx.translate(cx,cy); ctx.rotate(angle); ctx.globalAlpha=params.alpha;
        ctx.beginPath(); ctx.ellipse(0,-h*0.12,w*0.46,h*0.48,0,0,Math.PI*2); ctx.clip();
        if(patchImg){ ctx.drawImage(patchImg,-w/2,-h/2,w,h); }
        ctx.restore();
      }
    }

    // ====== 抠图编辑器（ROI GrabCut） ======
    function getCanvasPos(e){
      const r = edit.getBoundingClientRect();
      const scaleX = edit.width / r.width;
      const scaleY = edit.height / r.height;
      const clientX = e.touches? e.touches[0].clientX : (e.clientX ?? e.pageX);
      const clientY = e.touches? e.touches[0].clientY : (e.clientY ?? e.pageY);
      const x = (clientX - r.left) * scaleX;
      const y = (clientY - r.top) * scaleY;
      return { x: Math.max(0, Math.min(edit.width, x)), y: Math.max(0, Math.min(edit.height, y)) };
    }
    edit.addEventListener('pointerdown', (e)=>{
      if(!editImg) return; edit.setPointerCapture(e.pointerId);
      isDown=true; const p=getCanvasPos(e); startX=p.x; startY=p.y;
      if(tool==='fg'||tool==='bg'){ mctx.lineCap='round'; mctx.lineJoin='round'; mctx.lineWidth=brushSize; mctx.strokeStyle = (tool==='fg')?'rgba(255,77,79,0.9)':'rgba(77,163,255,0.9)'; mctx.beginPath(); mctx.moveTo(p.x,p.y);}
      else{ rect={x:p.x,y:p.y,w:1,h:1}; }
      drawEditor();
    });
    edit.addEventListener('pointermove', (e)=>{
      if(!isDown||!editImg) return; const p=getCanvasPos(e);
      if(tool==='fg'||tool==='bg'){ mctx.lineTo(p.x,p.y); mctx.stroke(); }
      else{ rect.x=Math.min(startX,p.x); rect.y=Math.min(startY,p.y); rect.w=Math.max(10,Math.abs(p.x-startX)); rect.h=Math.max(10,Math.abs(p.y-startY)); }
      drawEditor();
    });
    window.addEventListener('pointerup', ()=>{ isDown=false; });

    function drawEditor(){
      ectx.clearRect(0,0,edit.width,edit.height);
      if(!editImg) return;
      ectx.drawImage(editImg,0,0,edit.width,edit.height);
      ectx.globalAlpha=0.7; ectx.drawImage(marks,0,0); ectx.globalAlpha=1;
      if(rect){ ectx.fillStyle='rgba(0,0,0,0.25)'; ectx.fillRect(0,0,edit.width,edit.height);
        ectx.clearRect(rect.x,rect.y,rect.w,rect.h); ectx.strokeStyle='#fff'; ectx.setLineDash([6,4]); ectx.lineWidth=2; ectx.strokeRect(rect.x,rect.y,rect.w,rect.h); }
    }
    function toCanvasMax(img, maxSide=768){
      const w=img.naturalWidth||img.width, h=img.naturalHeight||img.height;
      const scale = Math.min(1, maxSide/Math.max(w,h));
      const c=document.createElement('canvas'); c.width=Math.max(1,Math.round(w*scale)); c.height=Math.max(1,Math.round(h*scale));
      c.getContext('2d').drawImage(img,0,0,c.width,c.height);
      return c;
    }
    async function fileToImage(file, maxSide=768){
      let url; try{
        if(file.type.includes('heic')||file.type.includes('heif')){ const blob=await heic2any({blob:file,toType:'image/jpeg'}); url=URL.createObjectURL(blob); }
        else{ url=URL.createObjectURL(file); }
      }catch(err){ url=URL.createObjectURL(file); }
      const img=await new Promise((resolve,reject)=>{ const im=new Image(); im.onload=()=>resolve(im); im.onerror=reject; im.src=url; });
      const c=toCanvasMax(img,maxSide); const out=new Image(); out.src=c.toDataURL('image/png'); await out.decode(); return out;
    }

    fileInput.addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return;
      statusEl.textContent='载入款式图…';
      const im = await fileToImage(f, 768);
      editImg = im; edit.width=im.width; edit.height=im.height; marks.width=im.width; marks.height=im.height; mctx.clearRect(0,0,marks.width,marks.height);
      rect={ x:Math.round(edit.width*0.2), y:Math.round(edit.height*0.15), w:Math.round(edit.width*0.6), h:Math.round(edit.height*0.5) };
      drawEditor(); statusEl.textContent='已载入款式图：框出贴片 + 涂几笔后执行 GrabCut。';
    });

    document.getElementById('autoRect').addEventListener('click', ()=>{
      if(!editImg) return;
      rect = { x: Math.round(edit.width*0.1), y: Math.round(edit.height*0.1), w: Math.round(edit.width*0.8), h: Math.round(edit.height*0.8) };
      drawEditor();
    });

    async function runGrabCut(iter=6){
      if(!window.cv){ statusEl.textContent='OpenCV 未加载。'; return; }
      if(!editImg){ statusEl.textContent='请先选择款式图。'; return; }
      if(!rect){ statusEl.textContent='请先框选矩形。'; return; }
      statusEl.textContent = `GrabCut (${iter})…`;

      // 只在 ROI 内做
      const roiX=rect.x|0, roiY=rect.y|0, roiW=rect.w|0, roiH=rect.h|0;
      const temp=document.createElement('canvas'); temp.width=roiW; temp.height=roiH;
      const g=temp.getContext('2d'); g.drawImage(editImg, roiX, roiY, roiW, roiH, 0,0, roiW, roiH);
      const src=cv.imread(temp); cv.cvtColor(src, src, cv.COLOR_RGBA2RGB, 0);

      const mask=new cv.Mat(src.rows, src.cols, cv.CV_8U); mask.setTo(new cv.Scalar(cv.GC_PR_BGD));
      const marksData = mctx.getImageData(roiX,roiY,roiW,roiH).data;
      for(let y=0;y<src.rows;y++){
        for(let x=0;x<src.cols;x++){
          const i=(y*roiW+x)*4;
          const r=marksData[i], g2=marksData[i+1], b=marksData[i+2], a=marksData[i+3];
          if(a>0){
            if(r>200 && g2<100 && b<100) mask.ucharPtr(y,x)[0]=cv.GC_FGD;      // 前景（红）
            else if(b>200 && r<100)      mask.ucharPtr(y,x)[0]=cv.GC_BGD;      // 背景（蓝）
            else                         mask.ucharPtr(y,x)[0]=cv.GC_PR_FGD;   // 其它标注当可能前景
          }
        }
      }

      const bgd=new cv.Mat(), fgd=new cv.Mat();
      try{
        cv.grabCut(src, mask, new cv.Rect(0,0,src.cols,src.rows), bgd, fgd, iter, cv.GC_INIT_WITH_MASK);
        const pr=new cv.Mat(), sure=new cv.Mat(), finalMask=new cv.Mat();
        cv.compare(mask, new cv.Mat(mask.rows, mask.cols, mask.type(), new cv.Scalar(cv.GC_PR_FGD)), pr, cv.CMP_EQ);
        cv.compare(mask, new cv.Mat(mask.rows, mask.cols, mask.type(), new cv.Scalar(cv.GC_FGD)), sure, cv.CMP_EQ);
        cv.bitwise_or(pr, sure, finalMask);

        const out=new cv.Mat(src.rows, src.cols, cv.CV_8UC4), rgba=new cv.Mat();
        cv.cvtColor(src, rgba, cv.COLOR_RGB2RGBA);
        const planes=new cv.MatVector(); cv.split(rgba, planes); planes.push_back(finalMask); cv.merge(planes, out);

        const outCanvas=document.createElement('canvas'); cv.imshow(outCanvas, out);
        const img=new Image();
        img.onload=()=>{ patchImg=img; thumb.src=img.src; statusEl.textContent='抠图完成：已贴到手指上'; drawLoopOnce(); };
        img.src=outCanvas.toDataURL('image/png');

        planes.delete(); rgba.delete(); out.delete(); pr.delete(); sure.delete(); finalMask.delete();
      }catch(err){ console.error(err); statusEl.textContent='GrabCut 失败：再多涂几笔前景/背景或缩小框后重试。'; }
      src.delete(); mask.delete(); bgd.delete(); fgd.delete();
    }
    document.getElementById('doGrabCut').addEventListener('click', ()=>runGrabCut(6));
    document.getElementById('refine').addEventListener('click', ()=>runGrabCut(3));

    // ====== 保存成 PNG ======
    snapBtn.addEventListener('click', ()=>{ const url=cvs.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='nail-tryon.png'; a.click(); });
  </script>
</body>
</html>
