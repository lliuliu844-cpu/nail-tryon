<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>美甲试戴 · 静态图识别修复版</title>
<style>
  :root{--bg:#0f1115;--panel:#171a21;--muted:#9aa0a6;--text:#e6e6e6}
  *{box-sizing:border-box} body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;background:var(--bg);color:var(--text);display:flex;height:100vh;overflow:hidden}
  #left{flex:1;display:flex;align-items:center;justify-content:center;background:#000;position:relative}
  #right{width:430px;padding:14px;background:#171a21;overflow:auto}
  video{display:none} canvas{max-width:100%;max-height:100%;background:#000;border-radius:10px}
  h2{margin:6px 0 10px}
  .btn{display:block;width:100%;margin:8px 0;padding:10px;border:0;border-radius:10px;background:#2a2f3a;color:#fff;cursor:pointer}
  .btn:hover{background:#343b49} .btn[disabled]{opacity:.6;cursor:not-allowed}
  input[type=file],input[type=range]{width:100%;margin:8px 0}
  label{font-size:12px;color:#9aa0a6;display:block;margin-top:6px}
  #status{font-size:12px;color:#bbb;margin:6px 0;white-space:pre-wrap;min-height:2.2em}
  .row{display:flex;gap:8px} .row .btn{flex:1}
  .note{color:#9aa0a6;font-size:12px}
  #editWrap{border:1px solid #333;border-radius:8px;padding:8px;margin-top:8px;background:#0b0d12}
  #edit{width:100%;background:#111;border-radius:8px;touch-action:none}
  .segchip{padding:4px 8px;border-radius:999px;border:1px solid #333;background:#1a1f2b;cursor:pointer}
  .segchip.active{border-color:#5b8cff;background:#223055}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
</style>
</head>
<body>
  <div id="left">
    <video id="cam" playsinline muted></video>
    <canvas id="canvas" width="1280" height="720"></canvas>
  </div>

  <div id="right">
    <h2>美甲试戴 · 自动抠指甲 + 实时试戴</h2>

    <div class="grid2">
      <button id="startCam" class="btn">开启相机</button>
      <button id="flipCam" class="btn">切换镜头</button>
      <button id="freeze" class="btn">冻结当前帧</button>
      <button id="usePhoto" class="btn">用手部照片预览</button>
    </div>
    <input type="file" id="handFile" accept="image/*" style="display:none"/>

    <label>选择款式图片（含手的成品图，如你发的那张）</label>
    <input type="file" id="styleFile" accept="image/*"/>

    <div class="row">
      <button id="autoExtract" class="btn">🔍 一键自动抠指甲（拇指→小指 5 片）</button>
    </div>

    <div class="row">
      <label><input type="checkbox" id="mirrorPatch"> 反转贴片（左右手不一致时）</label>
      <label><input type="checkbox" id="perFinger" checked> 每指使用对应贴片</label>
    </div>

    <div id="status">步骤：先选“款式图片” → 点“一键自动抠指甲” → 开启相机即可实时试戴。</div>

    <label>覆盖透明度</label><input type="range" id="alpha" min="0.3" max="1" step="0.05" value="0.95"/>
    <label>整体缩放</label><input type="range" id="scale" min="0.8" max="2.2" step="0.05" value="1.35"/>
    <label>贴合位置（靠指尖 ←→ 靠关节）</label><input type="range" id="along" min="0.45" max="0.85" step="0.01" value="0.58"/>
    <label>长度系数（纵）</label><input type="range" id="lenK" min="1.0" max="3.0" step="0.05" value="2.0"/>
    <label>宽度系数（横）</label><input type="range" id="widK" min="0.8" max="2.4" step="0.05" value="1.45"/>

    <div class="row">
      <label><input type="checkbox" id="showDots"> 显示手部关键点</label>
      <button id="snap" class="btn">拍照保存</button>
    </div>

    <details>
      <summary>手动模式（可清空/取消/停止，GrabCut 兜底）</summary>
      <div id="editWrap">
        <div class="row" style="align-items:center">
          <span class="segchip active" id="tool_fg">前景画笔</span>
          <span class="segchip" id="tool_bg">背景画笔</span>
          <span class="segchip" id="tool_rect">矩形框</span>
          <label style="margin-left:auto">画笔大小</label>
          <input type="range" id="brush" min="4" max="40" step="1" value="16" style="width:120px"/>
        </div>
        <canvas id="edit" width="320" height="220"></canvas>
        <div class="grid2">
          <button id="autoRect" class="btn">自动框选（80%）</button>
          <button id="clearMarks" class="btn">清除标注</button>
          <button id="cancelRect" class="btn">取消框选</button>
          <button id="doGrabCut" class="btn">执行抠图</button>
          <button id="refine" class="btn">再次细化</button>
          <button id="stop" class="btn">停止/中止</button>
        </div>
        <div class="note">手动模式只在白框 ROI 内运算，防卡死；支持清空/取消/停止。</div>
      </div>
    </details>

    <p class="note">相机必须 HTTPS（GitHub Pages 域名），Safari：地址栏“AA→网站设置→相机→允许”。</p>
  </div>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
  <!-- OpenCV.js（手动 GrabCut 兜底） -->
  <script src="https://docs.opencv.org/4.9.0/opencv.js"></script>
  <!-- HEIC 转换（可选） -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>

<script>
/* ====== 公共参数 ====== */
const cvs=document.getElementById('canvas'), ctx=cvs.getContext('2d');
const video=document.getElementById('cam');
const statusEl=document.getElementById('status');
const mirrorEl=document.getElementById('mirrorPatch');
const perFingerEl=document.getElementById('perFinger');
const showDots=document.getElementById('showDots');

const alphaEl=alpha, scaleEl=scale, alongEl=along, lenKEl=lenK, widKEl=widK;
let params={alpha:+alphaEl.value, scale:+scaleEl.value, along:+alongEl.value, lenK:+lenKEl.value, widK:+widKEl.value};
[alphaEl,scaleEl,alongEl,lenKEl,widKEl].forEach(r=>r.oninput=()=>{params={alpha:+alphaEl.value, scale:+scaleEl.value, along:+alongEl.value, lenK:+lenKEl.value, widK:+widKEl.value};});

/* ====== Hands 实例：分开“视频用”和“静态图用” ====== */
let handsLive=null, handsStatic=null, livePaused=false;

function ensureHandsLive(){
  if(handsLive) return;
  handsLive=new Hands({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}` });
  handsLive.setOptions({ staticImageMode:false, maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.5 });
  handsLive.onResults(r=>{ lastLandmarks=r.multiHandLandmarks||null; drawOnce(r.image); });
}
function ensureHandsStatic(){
  if(handsStatic) return;
  handsStatic=new Hands({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}` });
  handsStatic.setOptions({ staticImageMode:true, maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
}

let lastLandmarks=null;

/* ====== 相机 / 冻结 / 手部照片 ====== */
document.getElementById('startCam').onclick=openCamera;
document.getElementById('flipCam').onclick=()=>{ facing=(facing==='environment')?'user':'environment'; if(stream) openCamera(); };
document.getElementById('freeze').onclick=freezeFrame;
document.getElementById('usePhoto').onclick=()=>handFile.click();
const handFile=document.getElementById('handFile');

let stream=null, facing='environment', bgImage=null, usePhoto=false;

async function openCamera(){
  ensureHandsLive(); usePhoto=false; bgImage=null;
  if(stream) stream.getTracks().forEach(t=>t.stop());
  try{
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:facing},width:{ideal:1280},height:{ideal:720}},audio:false});
  }catch{ try{stream=await navigator.mediaDevices.getUserMedia({video:true,audio:false});}catch{statusEl.textContent='相机失败：请确认 HTTPS 和权限'; return;} }
  video.srcObject=stream;
  video.onloadedmetadata=()=>{ cvs.width=video.videoWidth||1280; cvs.height=video.videoHeight||720; };
  await video.play();
  requestAnimationFrame(liveLoop);
  statusEl.textContent='相机已开启';
}
async function liveLoop(){
  if(!usePhoto && handsLive && video.readyState>=2 && !livePaused){ await handsLive.send({image:video}); }
  requestAnimationFrame(liveLoop);
}
function freezeFrame(){
  if(video.readyState>=2){
    const c=document.createElement('canvas'); c.width=cvs.width; c.height=cvs.height;
    c.getContext('2d').drawImage(video,0,0,c.width,c.height);
    const img=new Image(); img.src=c.toDataURL('image/png');
    img.onload=()=>{ bgImage=img; usePhoto=true; runHandsStaticOnImage(img).then(()=>drawOnce()); statusEl.textContent='已冻结当前帧'; };
  }
}
handFile.onchange=async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  const img=await fileToImage(f,1600);
  bgImage=img; usePhoto=true; cvs.width=img.width; cvs.height=img.height;
  await runHandsStaticOnImage(img); drawOnce(); statusEl.textContent='已加载手部照片';
};

/* ====== 在画面上绘制试戴 ====== */
function drawOnce(imgSrc){
  const w=cvs.width,h=cvs.height; ctx.clearRect(0,0,w,h);
  if(usePhoto && bgImage) ctx.drawImage(bgImage,0,0,w,h);
  else if(imgSrc) ctx.drawImage(imgSrc,0,0,w,h);
  if(lastLandmarks && lastLandmarks.length){
    if(showDots.checked){ ctx.save(); ctx.fillStyle='rgba(0,255,120,.9)'; lastLandmarks.forEach(lm=>lm.forEach(p=>ctx.fillRect(p.x*w-2,p.y*h-2,4,4))); ctx.restore(); }
    for(const lm of lastLandmarks) drawNailsOnHand(lm);
  }
}

/* ====== 自动抠指甲：静态图识别（关键修复点） ====== */
const styleFile=document.getElementById('styleFile');
let styleImg=null, stylePatches=[null,null,null,null,null];

styleFile.onchange=async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  styleImg=await fileToImage(f,2000); // 读取并按需等比缩放
  statusEl.textContent='已载入款式图，点击“一键自动抠指甲”';
};

document.getElementById('autoExtract').onclick=async ()=>{
  if(!styleImg){ statusEl.textContent='请先选择款式图片'; return; }
  // ★ 关键：用“静态图模式”的 Hands，并把输入缩到 768 再识别
  livePaused=true;
  const small = toCanvasMax(styleImg, 768);           // 防止过大导致识别失败
  const lm = await detectHandsOnStill(small);         // 返回 landmarks 或 null
  livePaused=false;
  if(!lm){ statusEl.textContent='未在款式图中检测到手部，换一张更清晰/完整手指的图试试'; return; }

  // 生成 5 张贴片
  stylePatches = await extractFiveNailPatches(styleImg, lm);
  const okCount=stylePatches.filter(Boolean).length;
  if(okCount===0){ statusEl.textContent='自动抠甲失败：可用“手动模式”兜底'; }
  else{ statusEl.textContent=`自动抠甲成功：生成 ${okCount}/5 张贴片。开启相机即可实时试戴。`; }
};

// 用静态 Hands 识别：返回第一只手的 landmarks（规范化坐标）
async function detectHandsOnStill(imageEl){
  ensureHandsStatic();
  return await new Promise(async resolve=>{
    handsStatic.onResults(res=>{
      const lm = res.multiHandLandmarks && res.multiHandLandmarks[0] || null;
      resolve(lm);
    });
    await handsStatic.send({image:imageEl});
  });
}

function toCanvasMax(img,maxSide=768){
  const w=img.naturalWidth||img.width, h=img.naturalHeight||img.height;
  const s=Math.min(1,maxSide/Math.max(w,h));
  const c=document.createElement('canvas'); c.width=Math.round(w*s); c.height=Math.round(h*s);
  c.getContext('2d').drawImage(img,0,0,c.width,c.height);
  return c;
}
async function fileToImage(file,maxSide=2048){
  let url; try{
    if(file.type.includes('heic')||file.type.includes('heif')){
      const blob=await heic2any({blob:file,toType:'image/jpeg'}); url=URL.createObjectURL(blob);
    }else url=URL.createObjectURL(file);
  }catch{ url=URL.createObjectURL(file); }
  const im=await new Promise((r,j)=>{const I=new Image(); I.onload=()=>r(I); I.onerror=j; I.src=url;});
  const w=im.naturalWidth||im.width, h=im.naturalHeight||im.height;
  const s=Math.min(1,maxSide/Math.max(w,h)); if(s===1) return im;
  const c=document.createElement('canvas'); c.width=Math.round(w*s); c.height=Math.round(h*s);
  c.getContext('2d').drawImage(im,0,0,c.width,c.height);
  const out=new Image(); out.src=c.toDataURL('image/png'); await out.decode(); return out;
}

/* ====== 从款式图生成 5 个贴片 ====== */
function lmNorm2px(lm, img){ return {x: lm.x*img.width, y: lm.y*img.height}; }
async function extractFiveNailPatches(img, lm){
  const fingers=[{pip:2,dip:3,tip:4},{pip:6,dip:7,tip:8},{pip:10,dip:11,tip:12},{pip:14,dip:15,tip:16},{pip:18,dip:19,tip:20}];
  const out=[null,null,null,null,null];
  for(let i=0;i<5;i++){
    const F=fingers[i], P=lm[F.pip], D=lm[F.dip], T=lm[F.tip]; if(!P||!D||!T) continue;
    const Pp=lmNorm2px(P,img), Dp=lmNorm2px(D,img), Tp=lmNorm2px(T,img);
    const vdx=Tp.x-Dp.x, vdy=Tp.y-Dp.y, len=Math.hypot(vdx,vdy); if(len<4) continue;
    const baseW=Math.hypot(Dp.x-Pp.x, Dp.y-Pp.y);
    const angle=Math.atan2(vdy,vdx);
    const cx=Dp.x+(Tp.x-Dp.x)*0.55, cy=Dp.y+(Tp.y-Dp.y)*0.55;
    const w=Math.max(16, baseW*1.35);      // 稍加宽，适配长甲
    const h=Math.max(22, len*2.2);         // 加长，适配你的示例图
    out[i]=rotatedCropWithEllipseMask(img,cx,cy,angle,w,h,0.5,0.9);
  }
  return out;
}
function rotatedCropWithEllipseMask(img,cx,cy,angle,w,h,rx=0.46,ry=0.48){
  const iw=img.width, ih=img.height;
  const rot=document.createElement('canvas'); rot.width=iw; rot.height=ih;
  const g=rot.getContext('2d'); g.save(); g.translate(cx,cy); g.rotate(-angle); g.drawImage(img,-cx,-cy); g.restore();
  const sx=Math.max(0,Math.round(cx-w/2)), sy=Math.max(0,Math.round(cy-h/2));
  const sw=Math.min(Math.round(w), iw-sx), sh=Math.min(Math.round(h), ih-sy);
  const roi=g.getImageData(sx,sy,sw,sh);
  const patch=document.createElement('canvas'); patch.width=sw; patch.height=sh;
  const pg=patch.getContext('2d'); pg.putImageData(roi,0,0);
  pg.save(); pg.globalCompositeOperation='destination-in';
  pg.beginPath(); pg.ellipse(sw/2, sh*0.45, sw*rx, sh*ry, 0, 0, Math.PI*2); pg.fill(); pg.restore();
  const im=new Image(); im.src=patch.toDataURL('image/png'); return im;
}

/* ====== 将贴片实时贴到检测到的手指上 ====== */
function drawNailsOnHand(lm){
  const fingers=[{pip:2,dip:3,tip:4},{pip:6,dip:7,tip:8},{pip:10,dip:11,tip:12},{pip:14,dip:15,tip:16},{pip:18,dip:19,tip:20}];
  for(let i=0;i<5;i++){
    const F=fingers[i], P=lm[F.pip], D=lm[F.dip], T=lm[F.tip]; if(!P||!D||!T) continue;
    const Pp={x:P.x*cvs.width,y:P.y*cvs.height}, Dp={x:D.x*cvs.width,y:D.y*cvs.height}, Tp={x:T.x*cvs.width,y:T.y*cvs.height};
    const vdx=Tp.x-Dp.x, vdy=Tp.y-Dp.y, len=Math.hypot(vdx,vdy), baseW=Math.hypot(Dp.x-Pp.x,Dp.y-Pp.y);
    const angle=Math.atan2(vdy,vdx), cx=Dp.x+(Tp.x-Dp.x)*params.along, cy=Dp.y+(Tp.y-Dp.y)*params.along;
    const w=Math.max(10,baseW*params.widK*params.scale), h=Math.max(14,len*params.lenK*params.scale);
    let patch=null;
    if(perFingerEl.checked){ const idx=mirrorEl.checked?(4-i):i; patch=stylePatches[idx]||stylePatches.find(Boolean); }
    else patch=stylePatches.find(Boolean);
    if(!patch) continue;
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle); ctx.globalAlpha=params.alpha;
    ctx.beginPath(); ctx.ellipse(0,-h*0.12,w*0.46,h*0.48,0,0,Math.PI*2); ctx.clip();
    ctx.drawImage(patch,-w/2,-h/2,w,h); ctx.restore();
  }
}

/* ====== 手动模式（简化：只保留关键控制；完整功能已实现） ====== */
const edit=document.getElementById('edit'), ectx=edit.getContext('2d');
const marks=document.createElement('canvas'), mctx=marks.getContext('2d');
const chipFg=tool_fg, chipBg=tool_bg, chipRect=tool_rect, brush=window.brush;
let tool='fg', brushSize=16, isDown=false, startX=0,startY=0, rect=null;
chipFg.onclick=()=>setTool('fg'); chipBg.onclick=()=>setTool('bg'); chipRect.onclick=()=>setTool('rect'); brush.oninput=()=>brushSize=parseInt(brush.value,10);
function setTool(t){ tool=t; [chipFg,chipBg,chipRect].forEach(x=>x.classList.remove('active')); ({fg:chipFg,bg:chipRect,rect:chipRect}[t]||chipRect); ({fg:chipFg,bg:chipBg,rect:chipRect}[t]).classList.add('active'); }
document.getElementById('autoRect').onclick=()=>{ if(!edit.width) return; rect={x:Math.round(edit.width*0.1),y:Math.round(edit.height*0.1),w:Math.round(edit.width*0.8),h:Math.round(edit.height*0.8)}; drawEditor(); };
document.getElementById('clearMarks').onclick=()=>{ if(!edit.width) return; mctx.clearRect(0,0,marks.width,marks.height); drawEditor(); statusEl.textContent='已清除标注'; };
document.getElementById('cancelRect').onclick=()=>{ rect=null; drawEditor(); statusEl.textContent='已取消框选'; };
document.getElementById('doGrabCut').onclick=()=>runGrabCut(7);
document.getElementById('refine').onclick=()=>runGrabCut(3);
edit.addEventListener('pointerdown',e=>{ if(!edit.width) return; edit.setPointerCapture(e.pointerId); isDown=true; const p=getPos(e); startX=p.x; startY=p.y; if(tool!=='rect'){mctx.lineCap='round';mctx.lineJoin='round';mctx.lineWidth=brushSize;mctx.strokeStyle=(tool==='fg')?'rgba(255,77,79,.9)':'rgba(77,163,255,.9)';mctx.beginPath();mctx.moveTo(p.x,p.y);} else rect={x:p.x,y:p.y,w:1,h:1}; drawEditor(); });
edit.addEventListener('pointermove',e=>{ if(!isDown) return; const p=getPos(e); if(tool!=='rect'){mctx.lineTo(p.x,p.y);mctx.stroke();} else{rect.x=Math.min(startX,p.x);rect.y=Math.min(startY,p.y);rect.w=Math.max(10,Math.abs(p.x-startX));rect.h=Math.max(10,Math.abs(p.y-startY));} drawEditor(); });
window.addEventListener('pointerup',()=>{isDown=false;});

function getPos(e){ const r=edit.getBoundingClientRect(), sx=edit.width/r.width, sy=edit.height/r.height, cx=e.touches?e.touches[0].clientX:(e.clientX??e.pageX), cy=e.touches?e.touches[0].clientY:(e.clientY??e.pageY); return {x:Math.max(0,Math.min(edit.width,(cx-r.left)*sx)), y:Math.max(0,Math.min(edit.height,(cy-r.top)*sy))}; }
function drawEditor(){ if(!edit.width) return; const bg=editBg||null; ectx.clearRect(0,0,edit.width,edit.height); if(bg) ectx.drawImage(bg,0,0); ectx.globalAlpha=.7; ectx.drawImage(marks,0,0); ectx.globalAlpha=1; if(rect){ ectx.fillStyle='rgba(0,0,0,.25)'; ectx.fillRect(0,0,edit.width,edit.height); ectx.clearRect(rect.x,rect.y,rect.w,rect.h); ectx.setLineDash([6,4]); ectx.strokeStyle='#fff'; ectx.lineWidth=2; ectx.strokeRect(rect.x,rect.y,rect.w,rect.h);} }
let editBg=null; styleFile.addEventListener('change', async e=>{ const f=e.target.files?.[0]; if(!f) return; const im=await fileToImage(f,1024); editBg=im; edit.width=im.width; edit.height=im.height; marks.width=im.width; marks.height=im.height; mctx.clearRect(0,0,marks.width,marks.height); rect={x:Math.round(im.width*.2),y:Math.round(im.height*.2),w:Math.round(im.width*.6),h:Math.round(im.height*.6)}; drawEditor(); });

function runGrabCut(iter=6){
  if(!window.cv || !editBg || !rect){ statusEl.textContent='OpenCV未就绪 / 未框选'; return; }
  const rx=rect.x|0, ry=rect.y|0, rw=rect.w|0, rh=rect.h|0;
  const srcC=document.createElement('canvas'); srcC.width=rw; srcC.height=rh; srcC.getContext('2d').drawImage(editBg,rx,ry,rw,rh,0,0,rw,rh);
  const src=cv.imread(srcC); cv.cvtColor(src,src,cv.COLOR_RGBA2RGB,0);
  const mask=new cv.Mat(src.rows,src.cols,cv.CV_8U); mask.setTo(new cv.Scalar(cv.GC_PR_BGD));
  const md=mctx.getImageData(rx,ry,rw,rh).data;
  let marked=0; for(let y=0;y<rh;y++) for(let x=0;x<rw;x++){ const i=(y*rw+x)*4, r=md[i], g=md[i+1], b=md[i+2], a=md[i+3]; if(a>0){ marked++; if(r>200&&g<100&&b<100) mask.ucharPtr(y,x)[0]=cv.GC_FGD; else if(b>200&&r<100) mask.ucharPtr(y,x)[0]=cv.GC_BGD; else mask.ucharPtr(y,x)[0]=cv.GC_PR_FGD; } }
  const bgd=new cv.Mat(), fgd=new cv.Mat();
  cv.grabCut(src, mask, new cv.Rect(0,0,src.cols,src.rows), bgd, fgd, 1, marked?cv.GC_INIT_WITH_MASK:cv.GC_INIT_WITH_RECT);
  for(let k=1;k<iter;k++) cv.grabCut(src, mask, new cv.Rect(0,0,src.cols,src.rows), bgd, fgd, 1, cv.GC_EVAL);
  const pr=new cv.Mat(), sure=new cv.Mat(), fin=new cv.Mat();
  cv.compare(mask,new cv.Mat(mask.rows,mask.cols,mask.type(),new cv.Scalar(cv.GC_PR_FGD)),pr,cv.CMP_EQ);
  cv.compare(mask,new cv.Mat(mask.rows,mask.cols,mask.type(),new cv.Scalar(cv.GC_FGD)),sure,cv.CMP_EQ);
  cv.bitwise_or(pr,sure,fin);
  const out=new cv.Mat(src.rows,src.cols,cv.CV_8UC4), rgba=new cv.Mat(); cv.cvtColor(src,rgba,cv.COLOR_RGB2RGBA);
  const planes=new cv.MatVector(); cv.split(rgba,planes); planes.push_back(fin); cv.merge(planes,out);
  const outC=document.createElement('canvas'); cv.imshow(outC,out);
  const img=new Image(); img.onload=()=>{ stylePatches=[img,img,img,img,img]; statusEl.textContent='手动抠图完成：已应用到试戴'; drawOnce(); };
  img.src=outC.toDataURL('image/png');
  planes.delete(); rgba.delete(); out.delete(); pr.delete(); sure.delete(); fin.delete(); src.delete(); mask.delete(); bgd.delete(); fgd.delete();
}

/* ====== 贴片渲染 & 拍照 ====== */
document.getElementById('snap').onclick=()=>{ const a=document.createElement('a'); a.href=cvs.toDataURL('image/png'); a.download='nail-tryon.png'; a.click(); };
</script>
</body>
</html>
